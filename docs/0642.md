# JavaScript 执行上下文

> 原文:[https://www.javatpoint.com/javascript-execution-context](https://www.javatpoint.com/javascript-execution-context)

***这个话题对于那些是 JavaScript 开发人员或者想对 JavaScript 的工作过程有深入了解的人来说非常重要。*T3】**

在这里，在这一节中，我们将学习和理解 JavaScript 的执行上下文，在这里我们将讨论它是什么、它的类型、执行堆栈、执行上下文是如何创建的，以及所有关于执行阶段的内容。我们将逐一讨论每一点。让我们先从介绍部分开始。

什么是执行上下文

执行上下文是描述代码内部工作的概念。在 JavaScript 中，使 [JavaScript](https://www.javatpoint.com/javascript-tutorial) 代码能够被执行的环境就是我们所说的 **JavaScript 执行上下文**。决定哪个代码段可以访问代码中使用的函数、变量和对象的是执行上下文。在执行上下文中，特定的代码被逐行解析，然后变量和函数被存储在内存中。执行上下文类似于存储变量的容器，代码得到评估，然后执行。因此，正是执行上下文为特定代码的执行提供了环境。

### 执行上下文的类型

JavaScript 中执行上下文的类型有:

*   全球执行环境/GEC
*   功能执行上下文/前向纠错
*   评估执行上下文

开始逐一讨论:

## 全局执行上下文

GEC /全局执行上下文也称为基本/默认执行。任何不存在于任何函数中的 JavaScript 代码都将出现在全局执行上下文中。其名称“默认执行上下文”背后的原因是，当文件第一次加载到 web 浏览器中时，代码开始执行。GEC 执行以下两项任务:

*   首先，它为 Node.js 创建了一个全局对象，为浏览器创建了 Window 对象。
*   其次，将 Windows 对象引用到‘this’关键字。
*   创建一个内存堆来存储变量和函数引用。
*   然后，它将所有函数声明存储在内存堆区域中，并将变量存储在 GEC 中，初始值为“未定义”。

*有了上面的介绍，应该明白全局执行上下文在每个代码中只有一个，因为 JS 引擎是单线程的，因此，只可能有一个全局环境来执行 JavaScript 代码。*

## 功能执行上下文

前向纠错或功能执行代码是当发现任何函数调用时，由 JavaScript 引擎创建的上下文类型。每个函数都有自己的执行上下文，因此与 GEC 不同，FEC 可以不止一个。此外，FEC 可以访问 GEC 的整个代码，但 GEC 不可能访问 FEC 的所有代码。在 GEC 代码执行期间，会启动一个函数调用，当 JS 引擎找到该函数时，它会为该特定函数创建一个新的 FEC。

### 评估函数执行上下文

在 eval 函数中执行的任何 JS 代码都会创建并保存自己的执行上下文。然而，JavaScript 开发人员并不使用 eval 函数，但是它是执行上下文的一部分。

## 执行栈

执行栈也称为**调用栈**。

堆栈是以后进先出的形式存储值的数据结构。类似地，执行堆栈是一个跟踪脚本生命周期中开发的所有执行上下文的堆栈。JavaScript 开发人员必须知道这样一个事实，即 JavaScript 作为单线程工作，它能够一次在 web 浏览器中执行一个任务。因此，对于其他动作、函数和事件，创建一个堆栈，称为**执行堆栈**。GEC 位于执行堆栈的底部，默认情况下，它存在于堆栈中。因此，当开始执行 JS 代码时(即在 GEC 执行期间)，当代码中存在任何函数，并且 JS 引擎搜索它时，它立即为该函数创建一个函数执行上下文(FEC)，并将其推到执行上下文堆栈的顶部。在执行上下文堆栈顶部可用的特定执行上下文总是首先被 JS 引擎执行。一旦所有代码的执行完成，JS 引擎就会弹出函数的执行上下文，然后进入下一个，以此类推。通常，当脚本加载到浏览器中时，第一个元素将是全局执行上下文。但是，当检测到一个函数执行时，就会创建执行上下文，并将其虚拟地放在 GEC 的顶部。这个过程一直持续到整个代码的执行完成。

为了理解执行堆栈的工作过程，让我们考虑下面给出的示例代码:

```

let x = 'Hello World!';
function a() {
  console.log('It is the first function');
function b() {
  console.log('It is the second function');
}
b();
}
a();
console.log('It is GEC);

```

这是一个理解其工作原理的示例代码。

**说明:**

*   首先，将所有代码加载到浏览器中。
*   之后，JS 引擎在执行栈的顶部推送/插入 GEC。
    ![JavaScript Execution Context](../Images/d914a2b4a26232a8387c910a9742da49.png)
*   一旦 JS 引擎遇到第一个函数调用，它就会为它设置一个新的 FEC，并将其添加到当前执行堆栈的顶部。
    ![JavaScript Execution Context](../Images/e5cd70574133631a52225fb163a0b38b.png)
*   然后我们可以看到它是第一个函数中第二个函数的调用。因此，JS 引擎为第二个函数设置了一个新的 FEC，并将其插入堆栈的顶部。
    ![JavaScript Execution Context](../Images/8ccc1b3b6e9ca86a64452ae0f7767d36.png)
*   当第二个函数完成时，执行函数从堆栈中弹出，控件移动到堆栈中的下一个执行上下文，这只是第一个函数执行上下文。
    ![JavaScript Execution Context](../Images/3f9f99364297a97a06c453f2158f9043.png)
*   当第一个函数被完全执行时，第一个函数的执行栈从栈中弹出。因此，控制返回到代码的 GEC。
    ![JavaScript Execution Context](../Images/94749fe29e6d601a121fd86cce4cfd5b.png)
*   最后，当整个代码的执行完成时，JS 引擎从当前堆栈中移除 GEC。

以这种方式，执行栈的执行被执行。

## 创建执行上下文

首先创建一个执行上下文，然后对其进行管理。执行上下文的创建以两种方式执行:

### 创建阶段

创建阶段是 JS 引擎调用函数但不开始执行的阶段。在这个阶段，JS 引擎开始它的编译阶段，扫描特定的函数代码进行编译，但是不执行代码。创建执行上下文是 JavaScript 引擎的责任，它通过执行以下描述的任务来创建执行上下文:

**任务 1:创建激活对象/变量对象:**JavaScript 的一个特殊对象，它就像一个容器，保存着函数参数、变量以及内部函数声明的所有信息。有了这个，它就没有了 dunder proto 属性。

**任务 2:创建范围链:**完成任务 1 后，JS 引擎初始化范围链。范围链是一个包含当前函数所在的所有变量对象的列表。范围链也有 GEC 的变量对象，并携带当前函数变量对象。

*   **确定“this”值:**一旦创建了范围链，JS 引擎就会初始化“this”的值。

让我们借助下面的例子来理解激活对象的创建:

**示例代码 1**

```

function test (x, y) {
  var z = 10;

  var w = 5;
  w = function() {
    return x - y;
  }
}
test(12, 3);

```

现在，JS 引擎在调用 test()之后和执行其代码之前，为代码 1 创建一个 **executionContextObj** 。可以在下面的代码中看到:

```

executionContextObj = {
 variableObject: {}, // contains all variables, inner functions, arguments details of test()
 scopechain: [], // contains list of all the scopes for test()
 this // Value of this 
}

```

激活对象包含参数对象，该对象进一步包含函数参数的详细信息。它包含在当前函数中声明的每个函数和变量的属性名。在我们的例子中，**激活对象，例如，代码 1 将是:**

```

variableObject = {
  argumentObject : {
    0: x,
    1: y,
    length: 2
  },
  x: 3,
  y: 2
  z: undefined,
  w: undefined so the pointer points to the function definition of w
}

```

**说明:**

*   JS 引擎已经创建了参数对象，如上面的代码所示。此外，还有一个 length 属性，它包含函数中的参数总数。它只有属性名，没有值。
*   之后，对于函数中值被初始化为“未定义”的每个变量，JS 引擎在激活或变量对象上设置一个属性。这些参数也是函数中的变量，因此也是参数对象的属性。
*   如果存在变量已经作为参数对象属性存在的情况，那么 JS 引擎继续前进，而不采取任何进一步的动作。
*   当 JS 引擎在当前函数中找到函数定义时，通过使用函数的名称，它会创建一个新的属性。如上所述，函数定义存储在堆内存中。函数名属性指向它在堆内存中的定义。
*   所以，我们可以在上面的代码中看到 w 是一个变量。因此，它将获得“未定义”的值。但是，当找到同名函数时，将发生重写，其值将指向存储在堆内存中的函数 w 的定义。之后，JS 引擎设置范围链并确定“this”的值。

这样，创作阶段就起作用了。

### 执行阶段

执行阶段是完成创建阶段后的下一个阶段。执行阶段是 JS 引擎再次扫描代码中的函数的阶段，即再次用变量值更新变量对象，然后运行代码。让我们看看上面讨论的示例的执行阶段或完整代码:

**示例代码 2**

```

x = 10;
var y = 20;
z = function(val) {
  var p = 5;
  var q= 10;
    x = 30
  function test () {
    var r = 2;
  }
 test();
}
z(3);

```

首先，上述代码被加载到浏览器中。之后，JS 引擎开始编译阶段，以便创建执行对象。在编译阶段，JS 引擎只管理和处理声明，而不关心值。

**现在，在执行阶段，将按照第**行所述执行以下步骤

1.  变量 x 赋有 10，这使得 JS 引擎不会把它看作函数声明或变量声明，并进一步移动，即移动到第三行。在第三行，它没有做任何事情，因为它不是任何声明。
2.  接下来，JS 引擎在 GEC 对象中设置一个带有“z”(变量名)的属性，因为 z 是一个变量名，也在全局声明范围内，并将使用一个“未定义”的值初始化它。
3.  转到代码的第五行，JS 引擎遇到了一个函数声明。JS 引擎会将函数定义存储在堆内存中，然后设置一个指向特定堆内存位置的属性。函数中存储了什么并不重要，它只是指向它的位置。
4.  正如我们在最后一行看到的，它不是代码的任何声明。因此，JS 引擎不会执行任何操作。

因此，以这种方式，创建阶段和执行阶段的工作都会发生。

**GEC 物体经过创造阶段阶段**

在上面的解释中，我们看到了执行堆栈是如何通过示例代码 2 的执行和创建阶段创建的。但是，我们应该深入了解 GEC 和 FEC 的工作原理，仅适用于上述代码。考虑下面的 GEC 目标代码，例如代码 2:

```

        globalExecutionContextObj = {
activationbj: {
argumentObj : {
length:0
},
y: undefined,
z: Pointer to the function definition
},
scopeChain: [Global execution context variable object],
this: value of this
}

```

正如您在上面看到的，没有留下任何代码，JS 引擎进入执行阶段，再次扫描函数。JS 引擎更新变量值，然后按照下面每行描述的方式执行代码:

*   首先，JS 引擎发现变量对象中没有名为 x 的属性，所以它在 GEC 中添加了这个属性，并将其值初始化为 10。
*   接下来，JS 引擎发现变量对象中存在名为 y 的属性，因此将其值更新为 20。
*   最后，JS 引擎不会采取任何动作，因为它是一个函数声明。

现在，让我们看看执行阶段之后的 GEC 对象。

**执行阶段后的 GEC 对象**

**在我们的示例代码 2 中:**

```

globalExecutionContextObj = {
  activationbj: {
      argumentObj : {
          length:0
      },
      y: 20,
      z: Pointer to the function definition,
      x: 10
  },
  scopeChain: [Global execution context variable object],
  this: value of this
}

```

*   现在，随着 z()再次被调用，JS 引擎再次进入编译阶段。因此，它扫描函数以创建它的执行上下文对象。
*   函数 z()的参数是“val”，所以 JS 引擎会在 z()执行上下文对象的参数对象中添加“val”。然后它通过名称“val”创建一个属性。
*   接下来，它检查并发现 p 是否是函数激活对象中的一个属性。因此，它发现不存在这样的属性，所以它将添加 p 作为属性，然后将其值初始化为“undefined”。
*   接下来，JS 引擎的职责是查看 q 是否是函数激活对象中的一个属性。因此，它发现不存在这样的属性，所以它将添加 q 作为属性，然后将其值初始化为“undefined”。
*   然后，JS 引擎进行到下一行，因为 x = 30 不是一个声明。
*   然后，JS 引擎遇到一个 test()函数声明，它将函数定义存储在堆内存区域。然后，它设置一个名为“test”的属性，指向存储函数定义的位置。JS 引擎不关注存储在其中的值是什么。

**z 编译阶段后的执行对象**

**下面是编译阶段完成后 FEC 对象的代码:**

```

zExecutionContextObj = {
  activationbj: {
      argumentObj : {
          0: val,
          length:1
      },
      val: 3,
      p: undefined,
      q: undefined
      test: Pointer to the function definition,
  },
  scopeChain: [z variable object, Global execution context variable object],
  this: value of this
}

```

**示例代码 2 的编译阶段之后的代码如下所述执行:**

*   它是 test()函数调用，而不是声明，因此 JS 引擎不会做任何事情。
*   现在，JS 引擎将通过扫描来进入执行 z()函数的执行阶段。
*   在执行阶段，变量 p 和 q 得到 5 和 10 作为它们的值。
*   接下来，JS 引擎发现 x 不是一个声明，也不是 z 执行上下文对象上的任何属性，因此它通过作用域链移动到代码的 GEC，并在 GEC 看到名称为 x 的任何属性是否存在。如果没有找到，JS 引擎将创建一个名为 x 的新属性并初始化它。在示例代码 2 中，JS 引擎发现 GEC 对象上已经存在一个名为 x 的属性，因此它将其值从 10 更新为 30。应该注意的是，JS 引擎仅在这种情况下前进到 GEC，即当它在执行阶段找到一个不是当前执行上下文对象的属性的变量时
*   之后，JS 引擎设置一个测试属性，然后指向它的堆位置。

**执行阶段**后 *z* 的执行上下文对象

**在示例代码 2 中:**

```

zExecutionContextObj = {
  activationbj: {
      argumentObj : {
          0: val,
          length:1
      },
      val: 3,
      p: 5,
      q: 10
      test: Pointer to the function definition,
  },
  scopeChain: [z variable object, Global execution context variable object],
  this: value of this
}

```

*   在示例代码 2 中，JS 引擎再次进入编译阶段，为“test”创建执行上下文对象。
*   测试执行上下文对象可以访问在 z、变量上定义的每个函数，并且也在使用范围链的全局范围内。
*   同样，z 可以访问全局范围内的每个变量和对象。但是，它不能访问测试变量和对象。
*   代码的 GEC 无法访问 z 或测试变量或对象。

这就是执行上下文的创建和定义方式。

## 全局执行上下文与函数执行上下文

**两者有以下区别:**

| 全局执行上下文 | 函数执行上下文 |
| 它创建了一个全局范围。 | 它创建一个参数对象。 |
| 它创建了一个名为“this”的对象。 | 默认情况下，它指向窗口对象。 |
| 它为全局定义的函数和变量设置内存空间。 | 它为只在函数中定义的函数和变量设置存储空间。 |
| GEC 在内存中设置任何函数声明时，都会为变量声明分配一个默认值“undefined”。 | FEC 在内存中设置任何函数声明时，会为变量声明分配一个默认值“undefined”。这样，它也创建了自己的执行堆栈。 |

* * *